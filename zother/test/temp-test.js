document.addEventListener(
    'DOMContentLoaded',
    function() {
        const aside_left = document.querySelectorAll('.aside-left');
        const aside_right = document.querySelectorAll('.aside-right');
        const main = document.querySelectorAll('.main');
        // 左侧边栏内容
        aside_left.forEach(element => {
            element.innerHTML = '左边栏示例文本：左从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。'
        })
        // 右侧边栏内容
        aside_right.forEach(element => {
            element.innerHTML = '右边栏示例文本：左从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。'
        })
        // 主内容
        main.forEach(element => {
            element.innerHTML = '主内容示例：从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。从示例2中可见，Vector类实现了 __ iter __方法，解释器可以从Vector类对象中重复地取出元素并打印。如果要检查某一个对象是否为可迭代对象，其实可以使用isinstance( )函数，该函数用于判断对象是否为某一类型，但是用这个函数判断不一定准确(原因后面会说到)。'
        })

        // 左侧导航栏
        const nav_left = document.querySelector('.nav-left');
        const navLeft_newNode = document.createElement('img');
        navLeft_newNode.setAttribute('class','home-icon');
        navLeft_newNode.setAttribute('src','/assets/images/home-icon.svg');
        navLeft_newNode.setAttribute('alt','首页图标');
        nav_left.appendChild(navLeft_newNode);
        const lsLeft = ['编程', '动画', '漫画', '小说', '其他'];
        lsLeft.forEach(element => {
                var navLeft_newNode = document.createElement('a');
                navLeft_newNode.setAttribute('href','#');
                navLeft_newNode.textContent = element;
                nav_left.appendChild(navLeft_newNode);
        })
        // 右侧导航栏
        const nav_right = document.querySelectorAll('.nav-right');
        var navRight_newNode = document.createElement('form');
        navRight_newNode.setAttribute('class','form-search');
        navRight_newNode.setAttribute('action','/pages/search.html');
        navRight_newNode.setAttribute('method','get');
        navRight_newNode.setAttribute('target','_blank');
        var navRight_newNode_child = document.createElement('input');
        navRight_newNode_child.setAttribute('class','searchbox');
        navRight_newNode_child.setAttribute('type','search');
        navRight_newNode_child.setAttribute('name','q');
        navRight_newNode_child.setAttribute('placeholder','请输入搜索内容');
        navRight_newNode.appendChild(navRight_newNode_child);
        var navRight_newNode_child = document.createElement('input');
        navRight_newNode_child.setAttribute('class','submitbutton');
        navRight_newNode_child.setAttribute('type','submit');
        navRight_newNode_child.setAttribute('value','提交');
        navRight_newNode.appendChild(navRight_newNode_child);
        nav_right.forEach(element => {
            element.appendChild(navRight_newNode.cloneNode(true));
        })
        var navRight_newNode = document.createElement('form');
        navRight_newNode.setAttribute('class','form-theme');
        navRight_newNode.setAttribute('action','#');
        var navRight_newNode_child = document.createElement('label');
        navRight_newNode_child.setAttribute('class','themelabel');
        navRight_newNode_child.setAttribute('for','themelist');
        navRight_newNode_child.textContent = '主题';
        navRight_newNode.appendChild(navRight_newNode_child);
        var navRight_newNode_child = document.createElement('select');
        navRight_newNode_child.setAttribute('name','theme');
        navRight_newNode_child.setAttribute('id','themelist');
        var navRight_newNode_child_child = document.createElement('option');
        navRight_newNode_child_child.setAttribute('value', 'auto');
        navRight_newNode_child_child.textContent = '自动';
        navRight_newNode_child.appendChild(navRight_newNode_child_child);
        navRight_newNode_child_child = document.createElement('option');
        navRight_newNode_child_child.setAttribute('value', 'daylight');
        navRight_newNode_child_child.textContent = '白天';
        navRight_newNode_child.appendChild(navRight_newNode_child_child);
        navRight_newNode_child_child = document.createElement('option');
        navRight_newNode_child_child.setAttribute('value', 'moonlight');
        navRight_newNode_child_child.textContent = '夜晚';
        navRight_newNode_child.appendChild(navRight_newNode_child_child);
        navRight_newNode.appendChild(navRight_newNode_child);
        nav_right.forEach(element => {
            element.appendChild(navRight_newNode.cloneNode(true));
        })
        document.querySelector('.placeholder-nav').style.display = 'none';
        // 设置导航栏跳转样式
        var preNode;
        function nav_click() {
            if (preNode != null) {
                preNode.style.borderBottomColor = '';
                preNode.style.borderBottomWidth = '';
                preNode.style.borderBottomStyle = '';
                preNode.style.fontWeight = '';
            }
            this.style.borderBottomColor = 'black';
            this.style.borderBottomWidth = '0.25em';
            this.style.borderBottomStyle = 'solid';
            this.style.fontWeight = '600';
            preNode = this;
        }
        nav_left.querySelectorAll('a').forEach(element => {
            element.addEventListener('click', nav_click)
        })
    }
)